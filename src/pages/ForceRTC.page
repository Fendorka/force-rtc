<apex:page controller="ForceRTC" sidebar="false" showheader="true" standardstylesheets="false">

<html>
<head>

  <title>Force RTC</title>

    <apex:slds />
    <style>
        html, body {
            width: 100%;
            height; auto;
            background: #B0C4DF;
        }
        h1 {
            text-align: center;
        }
        #remoteVideo {
            max-width: 100%;
        }
        /* todo Show full local as a mirror, then on call add class that animates to this */
        #localVideo {
            max-width: 420px;
        }
        #localVideo.connected {
            z-index: 999;
            position: absolute;
            width: 84.5% !important;
            height: 17%;
            margin-top: 26%;
        }
        .videos {
            text-align: center;
            margin-top: 2rem;
        }
        .actions {
            text-align: center;
            margin-top: 2rem;
        }
        .hide {
            display: none !important;
        }
        .chatArea {
            margin: auto;
            width: 50%;
            padding-top: 2rem;
        }
        .createArea {
            margin: auto;
            width: 12rem;
            padding-top: 2rem;
        }
        .createButtons {
            margin: auto;
            width: 75%;
        }
    </style>
</head>

<body>

<div class="toaster" style="height: 4rem;"></div>

<div class="videos">

    <video id="localVideo" title="You" autoplay="true" muted="true"></video>

    <video id="remoteVideo" autoplay="true" class="hide"></video>
    <br />
</div>

<div class="createArea center hide">

    <select class="userList" />
    <br />
    <br />
    <div class="createButtons">
        <button id="create" class="slds-button slds-button_success">Create Connection</button>
    </div>
</div>

<br />
<br />
<br />

<div class="chatArea center hide">

    <div id="div"></div>

    <textarea 
        id="chat" 
        title="Hit enter to send" 
        placeholder="Send text to peer. Press Enter to send.">
    </textarea>

    <br />
</div>

</body>
    <!-- shim to insulate apps from spec changes and prefix differences.  -->
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>

  <script>
    'use strict()'

    const localVideo = document.getElementById('localVideo')
    const remoteVideo = document.getElementById('remoteVideo')
    
    const buttons = {}
    buttons.create = document.getElementById('create')
    buttons.create.onclick = createOffer

    const server = { urls: "stun:stun.l.google.com:19302" }

    const enterPressed = e => e.keyCode == 13
    const log = msg => div.innerHTML += `<p>${msg}</p>`

    const getMedia = navigator.mediaDevices.getUserMedia({video:true, audio:true})
        .then(stream => pc.addStream(localVideo.srcObject = stream))
        .catch(e => mkToast(e, 'error'))

    const haveAnswer = (conn) => {

        //Fix up the answer
        const answer = `${conn.jamiesmith__Answer__c}\r\n`

        const desc = new RTCSessionDescription({ type:"answer", sdp:answer })
        pc.setRemoteDescription(desc)
            .then(x => mkToast('Connected', 'success'))
            .catch(x => mkToast(x, 'warning'))
    }

    const poleForAnswer = (Id) => {

        const getConn = new Promise((resolve, reject) =>
            Visualforce.remoting.Manager.invokeAction(
                '{!$RemoteAction.ForceRTC.getConnection}',
                Id,
                (result, e) => e.status ? resolve(result) : reject(e.message)))
        .then(conn => conn.jamiesmith__Answer__c 
            ? haveAnswer(conn) 
            : setTimeout(() => poleForAnswer(Id), 10000))
        .catch(x => mkToast(x, 'warning'))
    }


    {   // if params, there's a connection made already so get it
        const Id = new URL(location.href).searchParams.get("id")
        if(Id){
            
            const getConn = new Promise((resolve, reject) =>
                Visualforce.remoting.Manager.invokeAction(
                    '{!$RemoteAction.ForceRTC.getConnection}',
                    Id,
                    (result, e) => e.status ? resolve(result) : reject(e.message))
            ).then(conn => {

                mkToast('Found Connection. Replying...', 'success')

                //Fix up the offer
                const offer = `${conn.jamiesmith__Offer__c}\r\n`
                
                // set _offer
                const desc = new RTCSessionDescription({ type:"offer", sdp:offer })
                pc.setRemoteDescription(desc)
                    .then(() => pc.createAnswer()).then(d => pc.setLocalDescription(d))
                    .catch(error => mkToast(error, 'error'))
                
                pc.onicecandidate = e => {

                    if (e.candidate){
                        return
                    }

                    // Answer = pc.localDescription.sdp

                    // Set Answer for Peer's pole to pickup
                    const setAnswer = new Promise((resolve, reject) =>
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.ForceRTC.setAnswer}',
                            Id,
                            pc.localDescription.sdp,
                            (result, e) => e.status ? resolve(result) : reject(e.message)))
                    .then(x => mkToast('Set Answer. Waiting for peer\'s connection...'))
                    .catch(error => mkToast(error, 'error'))
                }
                
            }).catch(error => mkToast(error, 'error'))
        }
        else {
            
            // Show creation stuff
            document.querySelector('.createArea').classList.remove('hide')

            // This is Client1
            const select = document.querySelector('.userList')
            select.innerHTML = `<option value="">--Select User--</option>`
            // Get potential ClientB's
            const getUsers = new Promise((resolve, reject) =>
                Visualforce.remoting.Manager.invokeAction(
                    '{!$RemoteAction.ForceRTC.getUsers}',
                    (result, e) => e.status ? resolve(result) : reject(e.message)))
            .then(x => x.map(u => select.innerHTML += `<option value="${u.Id}">${u.Name}</option>`))
            .catch(error => mkToast(error, 'error'))
        }
    }
    
    const pc = new RTCPeerConnection({ iceServers: [server] })
    pc.onaddstream = e => {
        remoteVideo.srcObject = e.stream
        localVideo.classList.add('hide')
        remoteVideo.classList.remove('hide')
        localVideo.classList.add('connected')
        localVideo.classList.remove('hide')
    }
    
    let dc // data channel
    pc.ondatachannel = e => dcInit(dc = e.channel)
    pc.oniceconnectionstatechange = e => log(pc.iceConnectionState)
    function dcInit() {

        dc.onopen = () => {
            document.querySelector('.chatArea').classList.remove('hide')
            mkToast('Chat available', 'success')
        }
        dc.onmessage = e => log(e.data)
    }

    function createOffer() {
        
        const userId = document.querySelector('.userList').value

        if(userId){
            mkToast('Creating connection.  This may take ~20 seconds.', 'info')
        }
        else {
            mkToast('Select a Peer to Connect to...', 'warning')
            return
        }
        
        dcInit(dc = pc.createDataChannel("chat"))

        getMedia.then(() => pc.createOffer())
            .then(d => pc.setLocalDescription(d))
            .catch(log)
            
        pc.onicecandidate = e => {

            if(e.candidate){
                return
            }

            // offer = pc.localDescription.sdp

            const mkConn = new Promise((resolve, reject) =>
                Visualforce.remoting.Manager.invokeAction(
                    '{!$RemoteAction.ForceRTC.mkConnection}',
                    pc.localDescription.sdp,
                    userId,
                    (result, e) => e.status ? resolve(result) : reject(e.message))
            ).then(conn => {
                
                mkToast('Connection created. Waiting for reply...', 'info')

                poleForAnswer(conn.Id)

            }).catch(error => mkToast(error, 'error'))
        }
    }

    chat.onkeypress = e => {
        
        if (!enterPressed(e)){
            return
        }

        dc.send(chat.value)
        log(chat.value)
        chat.value = ''
    }

    const mkToast = (msg, type) => {
        
        const cont = document.createElement('div')
        const toaster = document.querySelector('.toaster')

        cont.innerHTML =  `<div style="height: 4rem;">
            <div class="slds-notify_container slds-is-relative">
                <div class="slds-notify slds-notify_toast slds-theme_${type}" role="alert">
                    <span class="slds-assistive-text">${type}</span>
                    <span class="slds-icon_container slds-icon-utility-${type} slds-m-right_small slds-no-flex slds-align-top" title="Description of icon when needed">
                        <svg class="slds-icon slds-icon_small" aria-hidden="true">
                            <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="{!URLFOR($Asset.SLDS, '/assets/icons/utility-sprite/svg/symbols.svg#${type}')}" />
                        </svg>
                    </span>
                    <div class="slds-notify__content">
                        <h2 class="slds-text-heading_small">${msg}</h2>
                    </div>
                    <button class="close slds-button slds-button_icon slds-notify__close slds-button_icon-inverse" title="Close">
                        <svg class="slds-button__icon slds-button__icon_large" aria-hidden="true">
                            <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="{!URLFOR($Asset.SLDS, '/assets/icons/utility-sprite/svg/symbols.svg#close')}" />
                        </svg>
                        <span class="slds-assistive-text">Close</span>
                    </button>
                </div>
            </div>
        </div>`
        
        cont.querySelector('.close').onclick = () => toaster.innerHTML = ''
        toaster.innerHTML = ''
        toaster.appendChild(cont.childNodes[0])
    }

    
  </script>

  </html>

</apex:page>